---
title: "Lesson 6 Ornithology Theme"
author: "by Lorraine Gaudio"
date:   "`r paste('Lesson generated on', format(Sys.Date(), '%B %d, %Y'))`"
team: "Fall 2025"
output: 
  html_document: # To create an HTML document from R Markdown
    toc: true # Table of contents (TOC)
    toc_depth: 1 #(meaning that level 1, 2, and 3 headers will be included in the table of contents
    toc_float: # Float the table of contents to the left of the main document
      collapsed: false # Collapsed (defaults to TRUE) controls whether the TOC appears with only the top-level
      smooth_scroll: true # controls whether page scrolls are animated when TOC items are navigated to via mouse clicks.
    number_sections: true # Numbering starts with "#" (H1). Without H1 headers, the H2 headers ("##") will be numbered with 0.1, 0.2, and so on.
    css: ../assets/styles.css # This is the name of the CSS file to style the HTML document with Boise State Brand. The CSS file must be in the same directory as the R Markdown file.
    fig_caption: true #Whether figures are rendered with captions.
    df_print: paged # Printing data frames with interactivne scrolling
    code_folding: show # Enables you to include R code but have it hidden by default. (Show hide button)
    includes:
      in_header: ../assets/header.html
      after_body: ../assets/footer.html
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r eval=FALSE, include=FALSE}
title: "Lesson 6 Ornithology Theme"
author: "by Lorraine Gaudio"
date:   "`r paste('Lesson generated on', format(Sys.Date(), '%B %d, %Y'))`"
output: 
  pdf_document:
    toc: true
    toc_depth: 2
    number_sections: true
    citation_package: natbib
    fig_caption: true
    df_print: kable # Data frame printing
    includes:
      in_header: ../assets/header.tex
    latex_engine: xelatex  # Use xelatex to support fontspec
fontsize: 12pt
geometry: margin=1in
mainfont: "Garamond" # Sets the font of the entire document
sansfont: "Gotham-Book.otf" # Set sans-serif font to Gotham Book
monofont: "Courier New" # Set monospace font to Courier New
documentclass: scrreprt
linkcolor: boisestateblue # Customizes the color of hyperlinks
urlcolor: magenta # Customizes the color of URLs
citecolor: black # Customizes the color of citations
bibliography: references.bib # Bibliography file
biblio-style: apalike                 # âŸµ natbib needs a .bst style
natbiboptions: "round,authoryear"     # round brackets, Author (Year)
 
Or
title: "Lesson 6 Ornithology Theme"
author: "by Lorraine Gaudio"
date:   "`r paste('Lesson generated on', format(Sys.Date(), '%B %d, %Y'))`"
team: "Fall 2025"
output: 
  html_document: # To create an HTML document from R Markdown
    toc: true # Table of contents (TOC)
    toc_depth: 1 #(meaning that level 1, 2, and 3 headers will be included in the table of contents
    toc_float: # Float the table of contents to the left of the main document
      collapsed: false # Collapsed (defaults to TRUE) controls whether the TOC appears with only the top-level
      smooth_scroll: true # controls whether page scrolls are animated when TOC items are navigated to via mouse clicks.
    number_sections: true # Numbering starts with "#" (H1). Without H1 headers, the H2 headers ("##") will be numbered with 0.1, 0.2, and so on.
    css: ../assets/styles.css # This is the name of the CSS file to style the HTML document with Boise State Brand. The CSS file must be in the same directory as the R Markdown file.
    fig_caption: true #Whether figures are rendered with captions.
    df_print: paged # Printing data frames with interactivne scrolling
    code_folding: show # Enables you to include R code but have it hidden by default. (Show hide button)
    includes:
      in_header: ../assets/header.html
      after_body: ../assets/footer.html
```


# ğŸ’ª Welcome back to R! 

In lesson one through four you learned about objects, vectors, functions and how to handle missing data in R. In this lesson, you will learn about subsetting, extraction, and insertion in data frames. You rarely analyse an entire data table at once. You nearly always pull out specific rows or columns, or write back cleaned-up values. Mastering Râ€™s bracket "`[ ]`" syntax is therefore foundational.

To begin Lesson 6, follow these steps:

1. Open your course project for RStudio 
   
2. Create a new file. Today, let's use ğŸ“ "R Markdown" again (File > New File > R Markdown).

3. Type in the code provided in this document as you follow along with the video. Pause the video at anytime to answer learning skill prompts by digging deeper or add memo notes. 

4. Complete the assignment questions in this same document. 

5. Submit the RMD and RData file to the Canvas assignment for this lesson.

**Lesson Overview**

By the end of Lesson 6 you will be able to:

1. âš¡ Remember â€“ State Râ€™s basic subsetting template: `x[rows, cols]`.

2. ğŸ” Understand â€“ Describe the usefulness of creating a copy of original data.

3. ğŸ“ Apply â€“ Use logical tests + `which()` to select rows.

4. ğŸ“Š Analyze â€“ Summarize a subset to answer a question.

5. ğŸ› ï¸ Evaluate â€“ Choose an insertion (overwrite) vs. safe copy strategy

Keep these goals in mind as you move through each section.

# Build Dataframes

We'll need example dataframes to play with for this lesson. You can copy and paste the code that creates the dataframes. To learn more about how these dataframes were created, complete the Lesson 6 Point Boost!

## Simple Dataframe

We create trial_df as a simple example. Type or copy and paste the following code in a new code chunk and run.

```{r}
set.seed(1)
trial_vec <- sample(x = c(1:3, NA, NA, NA, NA), size = 25, replace = TRUE)
trial_vec
```

```{r}
# Example: Create a new vector trial_vec2 based on trial_vec
trial_vec2 <- ifelse(trial_vec == 2, "two", "not two")
```

Now, let's create a data frame using `trial_vec` and `trial_vec2`. Type the following code in a new code chunk and run.

```{r}
# Create a data frame with trial_vec and trial_vec2
trial_df <- data.frame(trial_vec, trial_vec2)
```

âœ… Check the data frame `trial_df`.

```{r}
# head(trial_df)  
head(trial_df) # Prints only for first 6 rows of trial_df
```

ğŸš¦ Are you ready? Remember to summon ?help whenever you need it.

## Field Biology

Dataset theme: Bird Band Observations ğŸ¦

This theme simulates data from a field biologist observing a population of birds, where most are untagged, but a small number have been previously captured and marked with colored leg bands. This is a very common practice in ecology and behavioral studies.

Weâ€™ll simulate a small inventory called `field_sightings` with two columns:
 
- Status  â€“ Describes whether the sighted bird is "Untagged" (the common case) or "Tagged" (the rare case).  

- Band_Color â€“ If a bird is untagged, the value is "None." If it is tagged, the value is one of several possible band colors.

**Copy and paste** the following code in a new code chunk.

```{r}
set.seed(8)
Status  <- sample(c(rep("Untagged", 4168), rep("Tagged", 302)))
Band_Color <- ifelse(Status == "Untagged", "None", 
                sample(c("Red", "Blue", "Green", "Yellow",
                         "Silver", "Black", "Orange", 
                         "White"), length(Status), replace = TRUE))
field_sightings <- data.frame(Status, Band_Color)

# View the data
View(field_sightings)
```

ğŸ” Look deeper: Why does the code have line breaks with indentation? What is the advantage of indented line breaks? When might this be useful for you? Create a memo note, demonstrate learning skill(s) used.

# Bracket Syntax

ğŸ“– Review Lesson 2 about indexing vectors `x[ ]`. Create a memo note, demonstrate learning skill(s) used. Create a memo note, demonstrate learning skill(s) used.

In this lesson we will use the same syntax to subset data frames.

- `x` is the object (vector, data frame, etc.)

- `[ ]` is the bracket operator for subsetting

- `x[rows, cols]` extracts specific rows and columns from `x`.

- rows and cols can be: indices (`1, 3:5`), names (`"Band_Color"`), or a logical vector / expression (`Status == "Tagged"`).

Type the following code in a new code chunk and run.

```{r}
field_sightings[1:3, ]  # âœ… Shows full row extraction
```

```{r}
# R's subsetting format:  x[rows, columns]
field_sightings[1:3, 1]  # âœ… Shows first three rows of first column
field_sightings[1:3, c(1, 2)]  # âœ… Shows first three rows of first and second
```

# Subsetting

We'll start with `trial_df` from earlier. Type the following code in a new code chunk and run.

```{r}
# Subsetting
# trial_df[ trial_df[ , "trial_vec"] == 2 , ] 
```

```{r}
direct_subset <- trial_df[ trial_df[ , "trial_vec"] == 2 , ]
head(direct_subset)
```

ğŸ“ Identify: which rows are extracted?

- TRUE (2 == 2)

- FALSE (1 == 2)

- FALSE (3 == 2)

- NA (NA == 2)

ğŸ¯ **Goal: isolate only the tagged birds.**

âš–ï¸ **Step 1** â€“ create a logical test using `[ ]`. Type the following code in a new code chunk and run.

```{r}
# Step 1 â€” Create and store the logical test (no big printout)
logical_test <- field_sightings[ , "Status"] == "Tagged"

# un-comment the line below to see the object logical_test
# print(logical_test) #prints a long list of values

# Instead, lets make a quick table of logical_test
table(logical_test, useNA = "ifany")   # counts of TRUE / FALSE / NA


```


ğŸ“Š **Step 2** â€“ Store subset of `field_sightings` data frame as a new data frame. Type the following code in a new code chunk and run.

```{r}
# Step 2 â€” Store the subset as a new data frame
tagged_only <- field_sightings[ field_sightings[ , "Status"] == "Tagged" , ]

head(tagged_only)
```

ğŸ” Look deeper:  How many *rows* did we keep? How could you check the number of rows in a data set? Create a memo note, demonstrate learning skill(s) used, including method you used to answer the question.

Type the following code in a new code chunk and run.

```{r}
n_tagged <- nrow(tagged_only)  # âœ… Check number of rows
print(n_tagged)
```

And 302 makes sense because of this code that helped create the dataset replicated "Tagged" 302 times. 

```{r}
# Confirm the filter worked
all(tagged_only[ , "Status"] == "Tagged")
unique(tagged_only[ , "Status"])
```

# Extraction

Using `which()` is a strategy to handle potential NA values in your data. When the test could include NA, wrap it in `which()` to drop unknowns.

Type the following R script in your document script and run. 

```{r}
rows_without_na <- which(trial_df[ , "trial_vec"] == 2)

which_subset <- trial_df[rows_without_na, ]

print(which_subset)
```

ğŸš€ Explore and Play: What is the difference between running `print(which_subset)` and `which_subset`? Create a memo note, demonstrate learning skill(s) used.

When you use a direct logical condition like `trial_df[ , "trial_vec"] == 2`, any NA values produce NA in the logical vector. Wrapping the condition in `which()` returns only the row positions where the test is TRUE, effectively dropping rows where the comparison is NA.


```{r}
# Two conditions
row_idx <- which(field_sightings[ , "Status"] == "Tagged" &
                  field_sightings[ , "Band_Color"] == "Blue")

subset_blue <- field_sightings[row_idx, ]
```

`row_idx` stores the row positions where both conditions are `TRUE`
- `Status == "Tagged"`
- `Band_Color == "Blue"`

Wrapping the test in `which()` returns only those positions (and automatically drops any rows where the comparison was NA). 

`subset_blue <- field_sightings[row_idx, ]` then keeps all columns but only the matching rows, preserving the original row order and row names.

Let's verify that it worked.

```{r}
head(subset_blue)
```

ğŸ—£ Comment (respond in one or two sentences): What changed in the data after subsetting (rows, columns, values)? What stayed the same (column names, column order, data types)?


## Selecting Columns

ğŸ§­ Select columns by name or by index using indexing.

Recall that columns can be chosen by index or name.

- By index: `field_sightings[ , 2]`   (second column)

- By name : `field_sightings[ , "Band_Color"]`

```{r}
head(subset_blue[ , "Band_Color"])
```

You can combine row + column ideas: band color of the first 10 birds. Type the following code in a new code chunk and run.

```{r}
field_sightings[1:10, "Band_Color"]
```

ğŸ¤” Why did we use `head()` in the first chunk and not in the second? Create a memo note, demonstrate learning skill(s) used.

## Selecting Multiple Columns

1. Compute a filtered row index with which(), then

2. Select multiple columns with df[row_idx, c("colA","colB", ...)].

```{r}
#  1) Row index with two conditions
row_idx <- which(
  field_sightings[ , "Status"] == "Tagged" &
  (field_sightings[ , "Band_Color"] == "Blue" |
   field_sightings[ , "Band_Color"] == "White")
)

# 2) Apply row + multi-column selection (select multiple columns by NAME)
tagged_blue_white <- field_sightings[row_idx, c("Status", "Band_Color")]

head(tagged_blue_white)

```

ğŸ—£ Comment: What changed after subsettingâ€”rows, columns, or both? Verify the filter worked: do all rows have Status == "Tagged" and Band_Color in c("Blue","White")? About how many rows remain compared to the full field_sightings? Why is that number smaller?

# Insertion

Insertion is the process of adding or modifying values in a data frame. You can insert new values or overwrite existing ones.

## Overwrite Values

Suppose we decide to rename "Untagged" to "Wild_Hatch" in the Status column.

ğŸŒŸ Good practice: make a backup first! Type the following code in a new code chunk and run.

```{r}
# Part 1
reintroduction <- field_sightings          # copy
indices_untagged <- which(field_sightings[ , "Status"] == "Untagged")
reintroduction[indices_untagged, "Status"] <- "Wild_Hatch"
```

ğŸ‘€ Check-in: Look at the format of that code: `x[rows, column] <- value`.
Here, we assign the character value `"Wild_Hatch"` into reintroduction at the rows given by `indices_untagged` and the `"Status"` column.

```{r}
# Verify the change
unique(reintroduction[ , "Status"])
```

ğŸ—£ Comment: Why is `field_sightings` unchanged while editing `reintroduction`? Why is this good practice? Create a memo note, demonstrate learning skill(s) used.

### Renaming columns 

```{r}
# Part 2 â€” Add a new column pattern
reintroduction[ , "Tag_Flag"] <- ifelse(
  reintroduction[ , "Status"] == "Tagged", "Yes", "No"
)
head(reintroduction[ , c("Status", "Tag_Flag")])
```


# Renaming Columns

Example 1: To rename a column, you can use the `colnames()` function. Type the following code in a new code chunk and run.

```{r}
# Part 2
names(reintroduction)

colnames(reintroduction) <- c("Band_Status", "Breeding_Cohort", "Tag_Flag")
head(reintroduction)
```

ğŸ“ Identify: Which columns are renamed? ğŸ” Look deeper: Create a list of all the different ways you might identify the column names of a data frame? Create a memo note, demonstrate learning skill(s) used.

___

Example 2: You can also rename a specific column by index. Type the following code in a new code chunk and run.

```{r}
reintroduction2 <- field_sightings     # âœ… Always copy first
names(reintroduction2)[which(names(reintroduction2) == "Status")] <- "Band_Status"
names(reintroduction2)[which(names(reintroduction2) == "Band_Color")] <- "Breeding_Cohort"
```
```{r}
head(reintroduction2)
```


# â¤ Assignment

Now it's your turn to practice creating and using vector objects. Follow the tasks below to complete part of the **technical skill practice assignment**.

1. Work through each task in order. Replace the ___ placeholder with your code or short written answer.

2. Run each completed line to be sure no errors appear and objects show in the Environment.

3. When finished, save your workspace and submit this R Markdown file (RMD) plus the .RData file.

## Task 0

ğŸš— Setup: Load the built-in data set `mtcars` and take a quick look. Identify what the columns contain and meaning of that content.

```{r ,eval=FALSE}
data("mtcars")   # already in memory but this keeps the workflow explicit
?mtcars        # help file for variable descriptions
View(mtcars)   # spreadsheet view (optional)
```

ğŸ—£ Comment: Explain Râ€™s basic subsetting template. Hint: It looks like `data[ rows , columns ]`

## Task 1 

âš–ï¸ Manual vs. Automatic

1. Create `Manual_Cars`: all rows where `am == 1` (manual), all columns.

```{r , eval=FALSE}
Manual_Cars <- ___
```

2. Use `nrow()` to record how many manual cars there are (store in `n_manual`).

```{r , eval=FALSE}
n_manual <- ___ # numeric count
```

## Task 2 

ğŸ” MPG by Cylinder

Extract mpg for each cylinder group into separate objects. Hint: Repeat the bracket pattern

```{r , eval=FALSE}
Four_Cyl_MPG  <- mtcars[ mtcars[ , "cyl"] == 4 , 
Six_Cyl_MPG   <- ___
Eight_Cyl_MPG <- ___
```

## Task 3

ğŸ§ Analyze Fuel Efficiency

1. Compute the mean mpg for each object.

```{r , eval=FALSE}
mean_4  <- mean(___)
mean_6  <- mean(___)
mean_8  <- mean(___)
```

2. ğŸ—£ Comment: Which cylinder group is most fuelâ€‘efficient? Answer in one word or number.

Most efficient: ___

## Task 4

ğŸš¦ Safe vs. Direct Editing

1. Make a safe copy of `mtcars` called `cars_safe`.

```{r , eval=FALSE}
cars_safe <- ___
```

2. Rename the `'am'` column in `cars_safe` to `"Transmission_Type"`.

```{r , eval=FALSE}
colnames(cars_safe)[___] <- ___
```

3. ğŸ—£ Comment: Explain *why* working on cars_safe (a copy) is safer than editing mtcars directly.  

Answer: ___

## Task 5

ğŸ“ Practice `which()`

Using `cars_safe`, extract the rows for Vâ€‘shaped engines (`vs == 0`) *and* horsepower (`hp`) above `150`. Use `which()` for the row indices and keep only `mpg`, `hp`, and `cyl` columns. Name the object `hi_power_v`.

1. Create `row_idx` for the condition above.

- `cars_safe[ , "vs"]` ? `0` 

- `&` 

- `cars_safe[ , "hp"]` ? `150`

- `cars_safe[row_idx , c("mpg","hp","cyl")]`


```{r , eval=FALSE}
row_idx      <- ___
```

2. Subset cars_safe with `row_idx` and columns `mpg`, `hp`, `cyl`. Name object `hi_power_v`.

```{r , eval=FALSE}
hi_power_v   <- ___
head(hi_power_v)
```

## Task 6

ğŸ›  Insertion Example

Add a new column called `"Efficiency_Class"` to `cars_safe`. Label `"High"` if `mpg >= 25`, `"Low"` otherwise.

Hint: use `ifelse()` and `cars_safe[ , "mpg"] >= 25, "?", "?"`

```{r , eval=FALSE}
cars_safe[ , "Efficiency_Class"] <- ___
```
 
# Save and Upload

1. You will be submitting **both** the R Markdown and the workspace file. The workspace file saves all the objects in your environment that you created in this lesson. 

Or you can click the "Save Workspace" button in the Environment pane. 

ğŸ’¾ **Always save the R documents before closing.**

2. Find the assignment in this week's module in Canvas and upload **both** the RMD and the workspace file.

# Today you practiced:

- Reading Râ€™s subsetting template x[rows, cols].

- Extracting rows with logical tests and which().

- Selecting columns by index or name.

- Safely overwriting values (insertion) after making a copy.

- Renaming columns.

ğŸ’ª Great job! Subsetting is the gateway to every data-cleaning task.
