---
title: "Lesson 6"
author: "by Lorraine Gaudio"
date:   "`r paste('Lesson generated on', format(Sys.Date(), '%B %d, %Y'))`"
team: "Fall 2025"
output: 
  html_document: # To create an HTML document from R Markdown
    toc: true # Table of contents (TOC)
    toc_depth: 1 #(meaning that level 1, 2, and 3 headers will be included in the table of contents
    toc_float: # Float the table of contents to the left of the main document
      collapsed: false # Collapsed (defaults to TRUE) controls whether the TOC appears with only the top-level
      smooth_scroll: true # controls whether page scrolls are animated when TOC items are navigated to via mouse clicks.
    number_sections: true # Numbering starts with "#" (H1). Without H1 headers, the H2 headers ("##") will be numbered with 0.1, 0.2, and so on.
    css: ../assets/styles.css # This is the name of the CSS file to style the HTML document with Boise State Brand. The CSS file must be in the same directory as the R Markdown file.
    fig_caption: true #Whether figures are rendered with captions.
    df_print: paged # Printing data frames with interactivne scrolling
    code_folding: show # Enables you to include R code but have it hidden by default. (Show hide button)
    includes:
      in_header: ../assets/header.html
      after_body: ../assets/footer.html
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r eval=FALSE, include=FALSE}
title: "Lesson 6"
author: "by Lorraine Gaudio"
date:   "`r paste('Lesson generated on', format(Sys.Date(), '%B %d, %Y'))`"
output: 
  pdf_document:
    toc: true
    toc_depth: 2
    number_sections: true
    citation_package: natbib
    fig_caption: true
    df_print: kable # Data frame printing
    includes:
      in_header: ../assets/header.tex
    latex_engine: xelatex  # Use xelatex to support fontspec
fontsize: 12pt
geometry: margin=1in
mainfont: "Garamond" # Sets the font of the entire document
sansfont: "Gotham-Book.otf" # Set sans-serif font to Gotham Book
monofont: "Courier New" # Set monospace font to Courier New
documentclass: scrreprt
linkcolor: boisestateblue # Customizes the color of hyperlinks
urlcolor: magenta # Customizes the color of URLs
citecolor: black # Customizes the color of citations
bibliography: references.bib # Bibliography file
biblio-style: apalike                 # âŸµ natbib needs a .bst style
natbiboptions: "round,authoryear"     # round brackets, Author (Year)
 
Or
title: "Lesson 6"
author: "by Lorraine Gaudio"
date:   "`r paste('Lesson generated on', format(Sys.Date(), '%B %d, %Y'))`"
team: "Fall 2025"
output: 
  html_document: # To create an HTML document from R Markdown
    toc: true # Table of contents (TOC)
    toc_depth: 1 #(meaning that level 1, 2, and 3 headers will be included in the table of contents
    toc_float: # Float the table of contents to the left of the main document
      collapsed: false # Collapsed (defaults to TRUE) controls whether the TOC appears with only the top-level
      smooth_scroll: true # controls whether page scrolls are animated when TOC items are navigated to via mouse clicks.
    number_sections: true # Numbering starts with "#" (H1). Without H1 headers, the H2 headers ("##") will be numbered with 0.1, 0.2, and so on.
    css: ../assets/styles.css # This is the name of the CSS file to style the HTML document with Boise State Brand. The CSS file must be in the same directory as the R Markdown file.
    fig_caption: true #Whether figures are rendered with captions.
    df_print: paged # Printing data frames with interactivne scrolling
    code_folding: show # Enables you to include R code but have it hidden by default. (Show hide button)
    includes:
      in_header: ../assets/header.html
      after_body: ../assets/footer.html
```


# ğŸ’ª Welcome back to R! 

In lesson one, through four you learned about objects, vectors, functions and how to handle missing data in R. In this lesson, you will learn about subsetting, extraction, and insertion in data frames. You rarely analyse an entire data table at once. You nearly always pull out specific rows or columns, or write back cleaned-up values. Mastering Râ€™s bracket "`[ ]`" syntax is therefore foundational.

To begin Lesson 6, follow these steps:

1. Open your course project for RStudio 
   
2. Create a new file. Today, let's try ğŸ“ "R Markdown"  (File > New File > R Markdown).

3. Type in the code provide in this document as you follow along with the video. Pause the video at anytime to answer assignment questions, dig deeper or add memo notes.

**Lesson Overview**

By the end of Lesson 6 you will be able to:

1. âš¡ Remember â€“ State Râ€™s basic subsetting template: `x[rows, cols]`.

2. ğŸ” Understand â€“ Describe the difference between `$` and `[ ]` for data frames.

3. ğŸ“ Apply â€“ Use logical tests + `which()` to select rows.

4. ğŸ“Š Analyze â€“ Summarize a subset to answer a question.

5. ğŸ› ï¸ Evaluate â€“ Choose an insertion (overwrite) vs. safe copy strategy

Keep these goals in mind as you move through each section.

# Quick Warmâ€‘up

Type the following code in a new code chunk and run.

```{r , eval=FALSE}
# Review the `sample()` function from lesson 3. 
set.seed(1)

args(sample)  # âœ… Check the arguments of sample()
```

Type the following code in a new code chunk and run.

```{r , eval=FALSE}
trial_vec <- sample(x = c(1:3, NA, NA, NA, NA), size = 25, replace = TRUE)
trial_vec
```

Type the following code in a new code chunk and run. Create a memo note, demonstrate learning skill(s) used.

```{r , eval=FALSE}
trial_vec <- sample(size = 25, replace = TRUE, x = c(1:3, NA, NA, NA, NA))
trial_vec 
```

ğŸ§ NOTICE: How does changing the order of arguments affect the output? Create a memo note, demonstrate learning skill(s) used.

Review `is.na()` and `which()` from lesson 4.

```{r , eval=FALSE}
# Review is.na() and which() from lesson 4 and Nesting from lesson 3
is.na(trial_vec)
which(is.na(trial_vec))  
which(!is.na(trial_vec)) 
```

ğŸš¦ Are you ready? Remember, you can summon help whenever you need it.

# Build a Data Frame

In lesson 2, you learned how to create a data frame using the function `data.frame()` to combine three vectors of equal length. You created these vectors using the `c()` function. In this lesson, you will create the vectors using the `ifelse()` function. Type the following code in a new code chunk.

```{r , eval=FALSE}
?ifelse
args("ifelse")  # âœ… Check the arguments of ifelse()
```

`ifelse()` is a vectorized function that allows you to create a new variable based on a condition. Type the following code in a new code chunk.

```{r , eval=FALSE}
# Example: Create a new vector trial_vec2 based on trial_vec
trial_vec2 <- ifelse(trial_vec == 2, "two", "not two")

```

This creates a new vector where each element is "two" if the corresponding element in `trial_vec` is 2, and "not two" otherwise. It takes three arguments:

-  condition: a logical test (e.g., `trial_vec == 2`)

- `value_if_true`: the value to assign if the condition is TRUE

- `value_if_false`: the value to assign if the condition is FALSE

Now, let's create a data frame using `trial_vec` and `trial_vec2`. Type the following code in a new code chunk and run.

```{r , eval=FALSE}
# Create a data frame with trial_vec and trial_vec2
trial_df <- data.frame(trial_vec, trial_vec2)
```

```{r , eval=FALSE}
# View(trial_df)  # âœ… Check the data frame with two columns
View(trial_df) # (opens a new tab in RStudio)
```

ğŸ¯ That was a practice round. Now, let's create a more complex data frame with two long vectors of equal length. 

Weâ€™ll simulate a small inventory called `snack_box` with two columns:
 
- Type  â€“ "Cereal" or "Marshmallow"  

- Shape â€“ shape names for marshmallows, placeholder for cereal

Type the following code in a new code chunk.

```{r , eval=FALSE}
set.seed(8)
Type  <- sample(c(rep("Cereal", 3091), rep("Marshmallow", 287)))
Shape <- ifelse(Type == "Cereal", "Plain", 
                sample(c("Heart", "Star", "Horseshoe", "Clover",
                         "Blue_Moon", "Pot_of_Gold", "Rainbow", 
                         "Red_Balloon"), length(Type), replace = TRUE))
snack_box <- data.frame(Type, Shape)

# View the data
View(snack_box)
```

ğŸ” Look deeper: Why does the code has line breaks with indentation? What is the advantage? Explain when to break and how far to indent. Create a memo note, demonstrate learning skill(s) used.

# Bracket Syntax

ğŸ“– Review Lesson 2 about indexing vectors `x[]`. Create a memo note, demonstrate learning skill(s) used. Create a memo note, demonstrate learning skill(s) used.

In this lesson we will use the same syntax to subset data frames.

- `x` is the object (vector, data frame, etc.)

- `[]` is the bracket operator for subsetting

- `x[rows, cols]` extracts specific rows and columns from `x`.

- rows and cols can be: indices (`1, 3:5`), names (`"Shape"`), or a logical vector / expression (`Type == "Marshmallow"`).

Type the following code in a new code chunk and run.

```{r , eval=FALSE}
snack_box[1:3, ]  # âœ… Shows full row extraction
```

```{r , eval=FALSE}
# R's subsetting format:  x[rows, columns]
snack_box[1:3, 1]  # âœ… Shows first three rows of first column
snack_box[1:3, c(1, 2)]  # âœ… Shows first three rows of first and second
```

# Subsetting

We'll start with `trial_df` from earlier. Type the following code in a new code chunk and run.

```{r , eval=FALSE}
trial_df[trial_df$trial_vec == 2, ]
# Test direct subsetting (will include NA rows)
direct_subset <- trial_df[trial_df$trial_vec == 2, ]
print(direct_subset)
trial_df[trial_df$trial_vec == 2, ]
```

ğŸ“ Identify: which rows are extracted?

- TRUE (2 == 2)

- FALSE (1 == 2)

- FALSE (3 == 2)

- NA (NA == 2)

ğŸ¯ **Goal: isolate only the marshmallows.**

âš–ï¸ **Step 1** â€“ create a logical test: `[ ]` vs. `$`. Type the following code in a new code chunk and run.

```{r , eval=FALSE}
snack_box[snack_box$Type == "Marshmallow", ]
```

`snack_box[snack_box$Type == "Marshmallow", ]` returns the rows where the condition is TRUE, along with all columns.

```{r , eval=FALSE}
snack_box$Type == "Marshmallow"            # TRUE/FALSE for each row
```

`snack_box$Type == "Marshmallow"` returns a logical vector. 

ğŸ“Š **Step 2** â€“ Store subset of `snack_box` data frame as a new data frame. Type the following code in a new code chunk and run.

```{r , eval=FALSE}
marshmallows_only <- snack_box[snack_box$Type == "Marshmallow", ]
```

ğŸ” Look deeper:  How many *rows* did we keep? How could you check the number of rows in a data set? Create a memo note, demonstrate learning skill(s) used, including method you used to answer the question.

Type the following code in a new code chunk and run.

```{r eval=FALSE, include=FALSE}
n_manual <- nrow(marshmallows_only)  # âœ… Check number of rows
nrow(marshmallows_only)
```

# Extraction

Using `which()` is a strategy to handle potential NA values in your data. When the test could include NA, wrap it in `which()` to drop unknowns.

Type the following R script in your document script and run. 

```{r , eval=FALSE}
rows_without_na <- which(trial_df$trial_vec == 2)

which_subset <- trial_df[rows_without_na, ]

print(which_subset)
```

ğŸš€ Explore and Play: What is the difference between running `print(which_subset)` and `which_subset`? Create a memo note, demonstrate learning skill(s) used.

When you use a direct logical condition like `trial_df$trial_vec == 2`, any `NA` values in the Type column will result in `NA` in the logical vector. You get only the indices where the condition is `TRUE`, effectively dropping/ignoring any rows where the comparison resulted in `NA`. You get a result that excludes rows with `NA` in the Type column

## `$` vs. `[ ]`

Type the following code in a new code chunk and run.

```{r , eval=FALSE}
row_idx <- which(snack_box[,"Type"] == "Marshmallow" & snack_box[,"Shape"] == "Star")
```

The bracket notation `[,"column_name"]` uses matrix-style indexing.

You can access the same columns using `$` notation where `snack_box$Type` replaces `snack_box[,"Type"]` and `snack_box$Shape` replaces `snack_box[,"Shape"]`. Type the following code in a new code chunk and run.

```{r , eval=FALSE}
row_idx2 <- which(snack_box$Type == "Marshmallow" & snack_box$Shape == "Star")
```

âš ï¸ Common Pain Point: Using `which()` but forgetting to subset columns. Type the following code in a new code chunk and run.

```{r , eval=FALSE}
subset_star <- snack_box[row_idx, ]
head(subset_star)  # âœ… Practice Task 5 logic with known data
head(x = subset_star, n= 3) 
```

âš¡ Explain the function `head()` and how it works with the `n` argument. Create a memo note, demonstrate learning skill(s) used.

## Selecting Columns

ğŸ§­ Method 1: Select columns by name using indexing.

Recall that columns can be chosen by index or name.

- By index: `snack_box[ , 2]`   (second column)

- By name : `snack_box[ , "Shape"]`

```{r , eval=FALSE}
head(subset_star[ , "Shape"])
```

You can combine row + column ideas: shapes of the first 10 marshmallows. Type the following code in a new code chunk and run.

```{r , eval=FALSE}
snack_box[1:10, "Shape"]
```

ğŸ¤” Why did we use `head()` in the first chunk and not in the second? Create a memo note, demonstrate learning skill(s) used.

ğŸ§­ Method 2: Select columns by name using `$`. Type the following code in a new code chunk and run.

```{r , eval=FALSE}
Cereal_Shapes <- snack_box$Shape[snack_box$Type == "Cereal"]
```

This creates a vector called `Cereal_Shapes` that contains only the shapes from rows where the type is `"Cereal"`. Type the following code in a new code chunk and run.

```{r , eval=FALSE}
Marshmallow_Shapes <- snack_box$Shape[snack_box$Type == "Marshmallow"]
```

It's particularly useful when you want to:

- Analyze the distribution of `"Shapes"` within each `"Type"`.

- Compare properties between different categories.

- Create separate vectors for further analysis by category.

This creates a vector called `Marshmallow_Shapes` with only shapes from marshmallow rows.

ğŸ‰ Bonus: Two conditions + column subset

Use `snack_box`: Pick shapes that are `Red_Balloon` and `Type = Marshmallow`. Type the following code in a new code chunk and run.

```{r , eval=FALSE}
marshmallow_data <- snack_box[snack_box$Type == "Marshmallow", ]

red_balloon_rows <- which(marshmallow_data$Shape == "Red_Balloon")

red_balloon_marshmallows <- marshmallow_data[red_balloon_rows, ]
```

# Insertion

Insertion is the process of adding or modifying values in a data frame. You can insert new values or overwrite existing ones.

## Overwrite Values

Suppose we decide to rename "Cereal" to "Grain" in the Type column.

ğŸŒŸ Good practice: make a backup first! Type the following code in a new code chunk and run.

```{r , eval=FALSE}
box_safe <- snack_box          # copy
indices_cereal <- which(snack_box$Type == "Cereal")
box_safe[indices_cereal, "Shape"] <- "Grain"
```

ğŸ‘€ Check-in: Look at the format of that code: `x[row, column] <- value`. The `<-` operator is not just for assigning a value to a variable name. `<- Grain` is assigned as the new value `"Grain"` to replace the existing value `"Cereal"`. The column name remains `"Type"`.

```{r , eval=FALSE}
# Verify the change
unique(box_safe$Shape)
```

ğŸ—£ Comment: Why is `snack_box` unchanged while editing `box_safe`? Why is this good practice? Create a memo note, demonstrate learning skill(s) used.

# Renaming Columns

Example 1: To rename a column, you can use the `colnames()` function. Type the following code in a new code chunk and run.

```{r , eval=FALSE}
names(box_safe)

colnames(box_safe) <- c("Piece_Type", "Piece_Shape")
head(box_safe)
```

ğŸ“ Identify: Which columns are renamed? ğŸ” Look deeper: Create a list of all the different ways you might identify the column names of a data frame? Create a memo note, demonstrate learning skill(s) used.

Example 2: You can also rename a specific column by index. Type the following code in a new code chunk and run.

```{r , eval=FALSE}
box_safe2 <- snack_box     # âœ… Always copy first
names(box_safe2)[which(names(box_safe2) == "Type")] <- "Piece_Type"
names(box_safe2)[which(names(box_safe2) == "Shape")] <- "Piece_Shape"
```

# Replace Missing Values

In lesson 4, you learned about handling missing values. Now, let's practice replacing missing values in a data frame. Recall that when a numeric vector has gaps, you can impute with the mean.

Type the following code in a new code chunk and run.

```{r , eval=FALSE}
# Before
trial_vec
```

```{r , eval=FALSE}
trial_vec[is.na(trial_vec)] <- mean(trial_vec, na.rm = TRUE)
```

The <- operator is not just for assigning a value to a variable name. Here the `<-` operator is used to assign the mean of the non-NA values` 

**Left side of the assignment**: `trial_vec[is.na(trial_vec)]`

- `x[ ]` index of a vector: Recall we can use "`:`" like `1:3` 

- index value is `is.na(trial_vec)` making logical vector (`TRUE`/`FALSE`) marking which elements are `NA`.

**Right side of the assignment**: `mean(trial_vec, na.rm = TRUE)`

- `mean()` calculates the mean of the non-NA values in `trial_vec`

The assignment operator <- takes the value from the right side, places it into the specific positions identified on the left side.

```{r , eval=FALSE}
# After
trial_vec
```

R took all the non-missing values, calculated their mean and replaced all the NA values with this decimal mean

# â¤ Assignment

Now it's your turn to practice creating and using vector objects. Follow the tasks below to complete part of the **technical skill practice assignment**.

1. Work through each task in order. Replace the ___ placeholder with your code or short written answer.

2. Run each completed line to be sure no errors appear and objects show in the Environment.

3. When finished, save your workspace and submit this R Markdown file (RMD) plus the .RData file.

## Task 0

ğŸš— Setup: Load the built-in data set `mtcars` and take a quick look. Identify what the columns contain and meaning of that content.

```{r ,eval=FALSE}
data("mtcars")   # already in memory but this keeps the workflow explicit
?mtcars        # help file for variable descriptions
View(mtcars)   # spreadsheet view (optional)
```

ğŸ—£ Comment: Explain Râ€™s basic subsetting template. Hint: It looks like `data[ rows , columns ]`

## Task 1 

âš–ï¸ Manual vs. Automatic

1. Create `Manual_Cars`: all rows where `am == 1` (manual), all columns.

```{r , eval=FALSE}
Manual_Cars <- ___
```

2. Use `nrow()` to record how many manual cars there are (store in `n_manual`).

```{r , eval=FALSE}
n_manual <- ___ # numeric count
```

## Task 2 

ğŸ” MPG by Cylinder

Extract mpg for each cylinder group into separate objects. Hint: Repeat the bracket pattern

```{r , eval=FALSE}
Four_Cyl_MPG  <- mtcars[mtcars$cyl == 4, "mpg"]
Six_Cyl_MPG   <- ___
Eight_Cyl_MPG <- ___
```

## Task 3

ğŸ§ Analyze Fuel Efficiency

1. Compute the mean mpg for each object.

```{r , eval=FALSE}
mean_4  <- mean(___)
mean_6  <- mean(___)
mean_8  <- mean(___)
```

2. ğŸ—£ Comment: Which cylinder group is most fuelâ€‘efficient? Answer in one word or number.

Most efficient: ___

## Task 4

ğŸš¦ Safe vs. Direct Editing

1. Make a safe copy of `mtcars` called `cars_safe`.

```{r , eval=FALSE}
cars_safe <- ___
```

2. Rename the `'am'` column in `cars_safe` to `"Transmission_Type"`.

```{r , eval=FALSE}
colnames(cars_safe)[___] <- ___
```

3. ğŸ—£ Comment: Explain *why* working on cars_safe (a copy) is safer than editing mtcars directly.  

Answer: ___

## Task 5

ğŸ“ Practice `which()`

Using `cars_safe`, extract the rows for Vâ€‘shaped engines (`vs == 0`) *and* horsepower (`hp`) above `150`. Use `which()` for the row indices and keep only `mpg`, `hp`, and `cyl` columns. Name the object `hi_power_v`.

1. Create `row_idx` for the condition above.

- `cars_safe$vs` ? `0` 

- `&` 

- `cars_safe$hp` ? `150`

- `cars_safe[row_idx , c("mpg","hp","cyl")]`


```{r , eval=FALSE}
row_idx      <- ___
```

2. Subset cars_safe with `row_idx` and columns `mpg`, `hp`, `cyl`. Name object `hi_power_v`.

```{r , eval=FALSE}
hi_power_v   <- ___
head(hi_power_v)
```

## Task 6

ğŸ›  Insertion Example

Add a new column called `"Efficiency_Class"` to `cars_safe`. Label `"High"` if `mpg >= 25`, `"Low"` otherwise.

Hint: use `ifelse()` and `cars_safe$mpg >= 25, "?", "?"`

```{r , eval=FALSE}
cars_safe$Efficiency_Class <- ___
```
 
# Save and Upload

1. You will be submitting **both** the R Markdown and the workspace file. The workspace file saves all the objects in your environment that you created in this lesson. You can save the workspace by running the following command in a code chunk of the R Markdown document:

```{r , eval=FALSE}
save.image("Assignment6_Workspace.RData")
```

Or you can click the "Save Workspace" button in the Environment pane. 

ğŸ’¾ **Always save the R documents before closing.**

2. Find the assignment in this week's module in Canvas and upload **both** the RMD and the workspace file.

# Today you practiced:

- Reading Râ€™s subsetting template x[rows, cols].

- Extracting rows with logical tests and which().

- Selecting columns by index or name.

- Safely overwriting values (insertion) after making a copy.

- Renaming columns and imputing simple missing values.

ğŸ’ª Great job! Subsetting is the gateway to every data-cleaning task.
