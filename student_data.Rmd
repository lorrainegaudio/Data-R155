---
title: "Student_Data"
author: "Lorraine Gaudio"
date: "2025-08-24"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

In this document, I wrangle student data. 


# Roster


I need the emailing roster so that I can email students the pre- and post- survey

```{r load-data, message=FALSE, warning=FALSE}
# ---- Step 1: Load Excel (sheets "900" and "1030") --------------------------
library(readxl)
library(dplyr)
library(janitor)

# Path to the roster file
roster_path <- "data/Class_Roster.xlsx"

# Sanity check
if (!file.exists(roster_path)) {
  stop("File not found: data/Class_Roster.xlsx (check working directory).")
}

# List sheets
sheets_available <- excel_sheets(roster_path)
required_sheets  <- c("900", "1030")
missing_sheets   <- setdiff(required_sheets, sheets_available)
if (length(missing_sheets)) {
  stop("Missing sheet(s): ", paste(missing_sheets, collapse = ", "),
       ". Found sheets: ", paste(sheets_available, collapse = ", "))
}

# Helper function: read, clean, drop NA course_id
read_roster_sheet <- function(path, sheet_name) {
  read_excel(path, sheet = sheet_name, col_types = "text") |>
    clean_names() |>
    filter(!is.na(course_id)) |>   # remove NA course_id
    mutate(section = sheet_name, .before = 1)
}

# Keep each section separate
roster_900  <- read_roster_sheet(roster_path, "900")
roster_1030 <- read_roster_sheet(roster_path, "1030")

# Quick peek
glimpse(roster_900)
glimpse(roster_1030)
```


I need to create several new columns in both datasets. 1. We need to create a random nine-digit identification number for each row called "ExternalDataReference" 2. We need to create a column "FirstName" and "LastName" from the column name. The column name, in both datasets, is formatted like this: "LastName,FirstName". It is comma-seperated with no space, and the last name is first.


```{r add-qualtrics-columns, message=FALSE, warning=FALSE}
library(dplyr)
library(tidyr)
library(stringr)

# Helper to generate unique 9-digit IDs (as zero-padded text)
make_ids <- function(n) {
  formatC(sample(0:999999999, n, replace = FALSE), width = 9, format = "d", flag = "0")
}

transform_roster <- function(df) {
  df %>%
    mutate(
      # 1) Unique 9-digit ExternalDataReference (text, preserves leading zeros)
      ExternalDataReference = make_ids(n())
    ) %>%
    mutate(name = as.character(name)) %>%
    # 2) Split "LastName,FirstName" -> LastName, FirstName
    separate(name, into = c("LastName", "FirstName"), sep = ",", fill = "right", remove = FALSE) %>%
    mutate(
      FirstName = str_trim(coalesce(FirstName, "")),
      LastName  = str_trim(coalesce(LastName, ""))
    )
}

# Apply to both datasets
roster_900  <- transform_roster(roster_900)
roster_1030 <- transform_roster(roster_1030)

# Quick check
roster_900  %>% select(section, name, FirstName, LastName, ExternalDataReference) %>% head()
roster_1030 %>% select(section, name, FirstName, LastName, ExternalDataReference) %>% head()
```
I rename email and "Email"and select columns c(FirstName, LastName, Email, ExternalDataReference)
Then I store both datasets in the data folder so I can upload them into Qualtrics.

```{r prep-for-qualtrics, message=FALSE, warning=FALSE}
library(readr)

# Helper to finalize Qualtrics format
finalize_roster <- function(df) {
  df %>%
    rename(Email = email) %>%
    select(FirstName, LastName, Email, ExternalDataReference)
}

# Apply to each section
roster_900_final  <- finalize_roster(roster_900)
roster_1030_final <- finalize_roster(roster_1030)

# Save to data folder as CSV
write_csv(roster_900_final,  "data/roster_900.csv")
write_csv(roster_1030_final, "data/roster_1030.csv")

# Quick peek
head(roster_900_final)
head(roster_1030_final)
```



# Pre-survey

I downloaded and manually cleaned the pre-survey data. I changed the column names to be consistent with the previous survey I did in the summer. 

```{r}
library(readxl)
pre_survey <- read_excel("data/pre_survey_manual_edit.xlsx")
available_fields <- read_excel("data/pre_survey_manual_edit.xlsx", 
    sheet = "available_fields")
```

```{r}
colnames(pre_survey)
```

## Instructor Tips

The first priority is to determine what tips do students have for me. I will read these tips, add important notes to the Class_Roster online and schedule check ins. 

```{r}
# Base R
# 1) Keep only the needed columns; rename `First _Name` -> First_Name
tips <- pre_survey[, c("Start_Date", "Last_Name", "First _Name", "instructor_tips")]
names(tips)[names(tips) == "First _Name"] <- "First_Name"

# 2) Trim whitespace in character columns (so "   " becomes "")
tips$instructor_tips <- trimws(tips$instructor_tips)

# 3) Keep rows where instructor_tips is not NA and not empty
tips <- tips[!is.na(tips$instructor_tips) & tips$instructor_tips != "", ]

# 4) Print all rows
print(tips)
```


```{r}
# dplyr
library(dplyr)

# 1) Keep only the needed columns; rename `First _Name` -> First_Name
tips <- pre_survey %>%
  select(Start_Date, Last_Name, First_Name = `First _Name`, instructor_tips)

# 2) Trim whitespace in character columns (so "   " becomes "")
tips <- tips %>%
  mutate(across(where(is.character), trimws))

# 3) Keep rows where instructor_tips is not NA and not empty
tips <- tips %>%
  filter(!is.na(instructor_tips) & instructor_tips != "")

# 4) Print all rows
print(tips, n = Inf)
```


## Low Skill Managing Files

The next thing we need to do is determine who scored two or below on familiarity_managing_files?

```{r}
str(pre_survey$familiarity_managing_files)
```


```{r}
# Base R

# 1) Keep only the columns we need; fix the space in First _Name
low_files <- pre_survey[, c("Last_Name", "First _Name", "Email_address", "familiarity_managing_files")]
names(low_files)[names(low_files) == "First _Name"] <- "First_Name"

# 2) Tidy text fields (trim spaces) and standardize email to lowercase
low_files$Last_Name <- trimws(low_files$Last_Name)
low_files$First_Name <- trimws(low_files$First_Name)
low_files$Email_address <- tolower(trimws(low_files$Email_address))

# 3) Recode NA values to 0
low_files$familiarity_managing_files[is.na(low_files$familiarity_managing_files)] <- 0

# 4) Filter to scores of 2 or below
low_files <- low_files[low_files$familiarity_managing_files <= 2, ]

# 5) Arrange for easy reading
low_files <- low_files[order(low_files$Last_Name, low_files$First_Name), ]

# 6) Print the table
print(low_files)
```


```{r}
library(dplyr)

low_files <- pre_survey %>%
  # 1) Keep only the columns we need; fix the space in First _Name
  select(Last_Name, First_Name = `First _Name`, Email_address, familiarity_managing_files) %>%
  
  # 2) Tidy text fields (trim spaces) and standardize email to lowercase
  mutate(
    across(c(Last_Name, First_Name, Email_address), trimws),
    Email_address = tolower(Email_address),
    
    # 3) Recode NA values to 0
    familiarity_managing_files = ifelse(is.na(familiarity_managing_files), 0, familiarity_managing_files)
  ) %>%
  
  # 4) Filter to scores of 2 or below
  filter(familiarity_managing_files <= 2) %>%
  
  # 5) Arrange for easy reading
  arrange(Last_Name, First_Name)

# 6) Print the table
print(low_files, n = Inf)
```


# Signature Assignment

I will use this data as my signature assignment example. To do this, I need to select the columns that are appropriate use. Then I need to add rows with fake data. I will need to randomly replicate values in each of the selected columns except for the id column. The id column needs to still be unique identifiers so the new, random rows need to have unique ids that are different from the real data.  

```{r}
# --- Setup ----
# Uses dplyr only; remove set.seed() if you don't want reproducibility
library(dplyr)
set.seed(42)

# Columns you want to keep (will silently drop any that don't exist)
cols_to_use <- c(
  "id","study_area","familiarity_managing_files","familiarity_running_R_console",
  "familiarity_saving_script","familiarity_packages","familiarity_loaddata",
  "familiarity_dataframes","familiarity_ggplot2","familiarity_pipe","adopter_group",
  "slider_curiosity","slider_autonomy","slider_thoroughness","slider_openmind",
  "slider_courage","slider_tenacity","slider_transparency","humans_versus_AI_control",
  "protect_human_agency","human_accountability","societal_impact_citizenship",
  "ethical_concerns_in_applications","systems_cause_harm",
  "data_privacy_intellectual_property","basic_capable_limits","decision_to_use",
  "specific_use_case","creative_uses"
)

# --- Function to add synthetic rows ----
add_fake_rows <- function(df, keep_cols, n_fake = nrow(df), id_col = "id") {
  # keep only requested, existing columns
  df1 <- df %>% select(any_of(keep_cols))
  stopifnot(id_col %in% names(df1))
  
  # If ID is a factor, coerce to character to avoid level issues when adding new IDs
  if (is.factor(df1[[id_col]])) {
    df1[[id_col]] <- as.character(df1[[id_col]])
  }
  
  # Helper: generate IDs that don't collide with existing
  make_unique_ids <- function(existing_ids, n) {
    # numeric/integer IDs: append a sequential block after the current max
    if (is.numeric(existing_ids)) {
      start <- suppressWarnings(max(existing_ids, na.rm = TRUE))
      if (!is.finite(start)) start <- 0
      out <- seq(from = start + 1, length.out = n, by = 1)
      # preserve integer class if needed
      if (inherits(existing_ids, "integer")) out <- as.integer(out)
      return(out)
    }
    # everything else -> character IDs with a clear prefix
    existing_chr <- as.character(existing_ids)
    # generate more than needed, then trim to first n unique & not-in-existing
    pool <- character(0)
    while (length(unique(setdiff(pool, existing_chr))) < n) {
      batch <- paste0(
        "FAKE_", sprintf("%05d", seq_along(pool) + 1L),
        "_", replicate(1000, paste0(sample(c(letters, 0:9), 6, TRUE), collapse = ""))
      )
      pool <- c(pool, batch)
    }
    unique_new <- setdiff(unique(pool), existing_chr)[seq_len(n)]
    return(unique_new)
  }
  
  existing_ids <- df1[[id_col]]
  new_ids <- make_unique_ids(existing_ids, n_fake)
  
  # Independently sample each non-ID column with replacement
  sampled_cols <- lapply(names(df1), function(nm) {
    x <- df1[[nm]]
    if (nm == id_col) {
      return(new_ids)
    } else {
      # sample preserves types (including factor levels) and NA frequency
      return(sample(x, size = n_fake, replace = TRUE))
    }
  })
  names(sampled_cols) <- names(df1)
  
  fake_df <- tibble::as_tibble(sampled_cols)
  
  # Bind real + fake; verify ID uniqueness
  out <- bind_rows(df1, fake_df)
  if (any(duplicated(out[[id_col]]))) {
    stop("Duplicate IDs detected after augmentation. Adjust ID-generation logic.")
  }
  out
}

# --- Use it ----
# Example: add the same number of fake rows as real rows
pre_survey_augmented <- add_fake_rows(
  df        = pre_survey,
  keep_cols = cols_to_use,
  n_fake    = nrow(pre_survey),  # change this to any number of synthetic rows you want
  id_col    = "id"
)

# Result:
# pre_survey_augmented now contains the selected columns + appended synthetic rows
# with unique IDs and per-column random replication (independent sampling).

```

```{r}
# Helper to generate unique "Su#######" IDs not colliding with existing
make_su_ids <- function(n, existing_ids = character()) {
  existing_ids <- as.character(existing_ids)
  out <- character(0)
  while (length(out) < n) {
    k <- max(1000L, (n - length(out)) * 3L)  # oversample to reduce loops
    # 0..9,999,999 (allows leading zeros to ensure 7 digits)
    candidates <- sprintf("Su%07d", sample.int(10^7, k, replace = TRUE) - 1L)
    candidates <- setdiff(unique(candidates), c(existing_ids, out))
    out <- c(out, candidates)
  }
  out[seq_len(n)]
}

# Identify FAKE rows and coerce ID to character to avoid factor-level issues
fake_rows <- grepl("^FAKE", pre_survey_augmented$id)
pre_survey_augmented$id <- as.character(pre_survey_augmented$id)

# Generate and assign new unique IDs
pre_survey_augmented$id[fake_rows] <- make_su_ids(
  n = sum(fake_rows),
  existing_ids = pre_survey_augmented$id[!fake_rows]
)

# Sanity check: all IDs must be unique
stopifnot(!any(duplicated(pre_survey_augmented$id)))
```

```{r}
# Randomly shuffle the row order (reproducible if you keep the seed)
set.seed(42)
pre_survey_augmented <- dplyr::slice_sample(pre_survey_augmented, prop = 1)
rownames(pre_survey_augmented) <- NULL

```
```{r}
# Save to data folder as CSV
write_csv(pre_survey_augmented,  "data/signature_assignment_example.csv")
```

